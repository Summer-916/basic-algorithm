0.顺序存储定义
把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。

1.顺序表中元素存储位置的计算
LOC(ai) = LOC(ai) + (i-1)*sizeof(ai)
可见，所有元素的存储位置都可以都第一个元素的存储位置计算获得。这种元素访问的时间复杂度为O(1),称作随机存取。

0+1.顺序表的特点
- 以物理位置相邻表示逻辑关系(地址连续)
- 每个元素依次存放
- 任一位置均可以存取(优点)
- 各个数据元素类型相同

2.数组与vector
(1)静态数组 - 普通数组
普通数组无法直接修改大小，不能直接插入，删除元素，因为静态数组的大小在定义时就确定好了。
(2)动态数组 - Vector
1. 构造函数：
   - vector()：创建一个空的std::vector。
   - vector(size_type count, const T& value = T())：创建一个包含count个元素的std::vector，每个元素都初始化为value。
   - vector(InputIt first, InputIt last)：创建一个包含范围 `[first, last)` 内元素的`std::vector。

2. 容量相关函数：
   - size()：返回std::vector中的元素数量。
   - empty()：检查std::vector是否为空。
   - resize(size_type count, T value = T())：修改std::vector的大小为count，如果新的大小大于当前大小，将会插入默认构造的元素；如果新的大小小于当前大小，将会删除多余的元素。
   - reserve(size_type new_cap）：请求std::vector的容量至少达到new_cap，如果new_cap超过当前容量，则重新分配存储空间。

3. 元素访问函数：
   - `operator[]`：通过索引访问指定位置的元素。
   - `at()`：通过索引访问指定位置的元素，并进行边界检查。
   - `front()`：返回`std::vector`的第一个元素的引用。
   - `back()`：返回`std::vector`的最后一个元素的引用。
   - `data()`：返回指向`std::vector`内部存储数据的指针。

4. 元素插入和删除函数：
   - `push_back(const T& value)`：在`std::vector`的末尾插入一个元素。
   - `pop_back()`：删除`std::vector`的末尾元素。
   - `insert(iterator pos, const T& value)`：在指定位置插入一个元素。
   - `erase(iterator pos)`：删除指定位置的元素。
   - `erase(iterator first, iterator last)`：删除范围 `[first, last)` 内的元素。
注:iterator是迭代器,vector.begin()或vector.end()
5. 查找和计数函数：
   - `find(const T& value)`：在`std::vector`中查找指定值的第一个匹配元素，并返回其迭代器。
   - `count(const T& value)`：计算`std::vector`中指定值的匹配元素数量。

6. 其他函数：
   - `clear()`：清空`std::vector`中的所有元素。
   - `swap(vector& other)`：交换两个`std::vector`的内容。

这些函数提供了广泛的功能，可以对`std::vector`进行插入、删除、查找和修改等操作。您可以根据需要选择适当的函数来操作`std::vector`并满足您的需求。

请注意，上述函数列表并非详尽无遗，还有一些其他成员函数和非成员函数可以用于更高级的操作和算法。您可以参考C++标准库的文档以获取更全面的了解。

补充: 当操作顺序表时，视情况将索引视为循环轮数(记录循环次数重要)或指针(记录指针与顺序表尾或另一个指针的位置重要)。

3. 顺序表局限性
- 空间复杂度高
- 存储空间分配不灵活